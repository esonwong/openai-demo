import Head from 'next/head'
import Image from 'next/image'
import { Inter } from 'next/font/google'
import styles from '@/styles/Home.module.css'
import { Configuration, OpenAIApi, ChatCompletionRequestMessage, ChatCompletionRequestMessageRoleEnum } from "openai";
import { useEffect, useState } from 'react'
import { Toaster, toast } from 'sonner'


const configuration = new Configuration({
  apiKey: process.env.NEXT_PUBLIC_OPENAI_API_KEY,
  basePath: "https://proxy.esonwong.workers.dev/v1",
});
const openai = new OpenAIApi(configuration);


const inter = Inter({ subsets: ['latin'] })

interface Message extends ChatCompletionRequestMessage {
  enabled: boolean
}

const defauleMessages: Message[] = [
  { "role": "system", "content": "你是一个翻译助手，帮且我翻译中文成英语，如果我说英文指出我说话的错误。", "enabled": true },
  { "role": "user", "content": "我是谁？", "enabled": true },
  { "role": "assistant", "content": "Who I am?", "enabled": true },
  { "role": "user", "content": "Where are you?", "enabled": true },
  { "role": "assistant", "content": "你在哪里？", "enabled": true },
  { "role": "user", "content": "早上好！", "enabled": true },
]

export default function Home() {
  const [modelList, setModelList] = useState<any[]>([
    { id: "gpt-3.5-turbo" },
    { id: "gpt-3.5-turbo-0301" }
  ])
  const [model, setModel] = useState("gpt-3.5-turbo")
  const [result, setResult] = useState<any>(null)
  const [temperature, setTemperature] = useState(0.5)
  const [topP, setTopP] = useState(0.5)
  const [messages, setMessages] = useState<Message[]>(defauleMessages)
  const [loading, setLoading] = useState(false)

  // useEffect(() => {
  //   openai.listModels().then((res) => {
  //     setModelList(res.data.data)
  //   })
  // }, [])


  const onSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault()
    const form = e.currentTarget

    try {
      setLoading(true)
      const completion = await openai.createChatCompletion({
        model,
        messages: messages.filter((message) => message.enabled).map(({ role, content }) => ({ role, content })),
        max_tokens: Number(form.max_tokens.value),
        top_p: topP,
        n: Number(form.n.value),
        frequency_penalty: Number(form.frequency_penalty.value),
        presence_penalty: Number(form.presence_penalty.value),
      });
      setResult(completion.data)
    } catch (e: any) {
      toast.error(e.response?.data?.error?.message || e.message)
    } finally {
      setLoading(false)
    }
  }

  const addMessage = (message: Message) => {
    setMessages((messages) => [...messages, message])
  }

  const onRemoveMessage = (index: number) => {
    setMessages((messages) => messages.filter((_, i) => i !== index))
  }



  return (
    <>
      <Head>
        <title>Chat Demo</title>
        <meta name="description" content="Generated by create next app" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <meta name="theme-color" content="rgba(240, 45, 144, 1)" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <main className={styles.main}>

        <h2>
          gpt-3.5-turbo
        </h2>

        <form className={styles.form} onSubmit={onSubmit}>
          <div>
            <button type="submit" className={styles.submit} disabled={loading} >Submit</button>
          </div>
          <p>
            <label >
              <span> Model </span>
              <select name="model" id="model" value={model} onChange={(e) => setModel(e.target.value)}>
                {modelList.map((model) => (
                  <option value={model.id} key={model.id}>{model.id}</option>
                ))}
              </select>
            </label>
          </p>
          <div className={styles.messageContainer}>
            <label>
              <span>Messages</span>
            </label>
            <ul className={styles.messages}>
              {messages.map((message, index) => (
                <li className={styles.message} key={index}>
                  <input type="checkbox" checked={message.enabled}
                    onChange={(e) => {
                      setMessages((messages) => messages.map((message, i) => {
                        if (i === index) {
                          return {
                            ...message,
                            enabled: e.target.checked
                          }
                        }
                        return message
                      }))
                    }}
                  />
                  <span className={styles.role}>
                    {message.role}:
                  </span>
                  <pre className={styles.content}>
                    {message.content}
                  </pre>
                  <button onClick={(e) => {
                    e.preventDefault()
                    onRemoveMessage(index)
                  }}>Remove</button>
                </li>
              ))}

            </ul>
          </div>
          <p className={styles.tip}>
            勾选的消息会被发送给 OpenAI API 生成回复。API 会学习上面的对话的 assistant 回复的模式来生成回复。
          </p>
          <div className={styles.messageContainer}>
            <label>
              <span>Answers</span>
            </label>
            <ul className={styles.messages}>
              {result?.choices?.map((choice: any, index: number) => (
                <li className={styles.message} key={index}>
                  <span className={styles.role}>
                    (result{index + 1}) assistant:
                  </span>
                  <pre className={styles.content}>
                    {choice.message.content}
                  </pre>
                  <button onClick={(e) => {
                    e.preventDefault()
                    addMessage({
                      role: "assistant",
                      content: choice.message.content,
                      enabled: true
                    })
                  }}>Add</button>
                </li>
              ))}
            </ul>
          </div>
          <p className={styles.total}>
            Prompt Tokens: {result?.usage?.prompt_tokens || 0} /  Completion Tokens: {result?.usage?.completion_tokens || 0} / Total Tokens {result?.usage?.total_tokens || 0}
          </p>
          <p className={styles.tip}>
            $0.002 / 1K tokens
          </p>
          <p>
            <label >
              <span> Add Message </span>
              <select name="system_role" id="system_role" className={styles.roleSelect}>
                <option value="user">User</option>
                <option value="system">System</option>
                <option value="assistant">Assistant</option>
              </select>
              <input type="text" name="content" id="content" />
              <button onClick={(e) => {
                e.preventDefault()
                const role = document.querySelector("#system_role") as HTMLSelectElement
                const content = document.querySelector("#content") as HTMLInputElement
                addMessage({
                  role: role.value as ChatCompletionRequestMessageRoleEnum,
                  content: content.value,
                  enabled: true
                })
              }}>Add</button>
            </label>
          </p>
          {/* <p>
            <label >
              <span> Prompt </span>
              <textarea name="prompt" id="prompt" cols={30} rows={10}></textarea>
            </label>
          </p> */}
          <p>
            <label >
              <span> Max Tokens </span>
              <input type="number" name="max_tokens" id="max_tokens" defaultValue={1024} />
            </label>
          </p>
          <p className={styles.tip}>
            控制生成的文本 tokens 数量。输入和输出的 tokens 数量之和不能超过 4096。
          </p>
          <p>
            <label >
              <span> N </span>
              <input type="number" name="n" id="n" defaultValue={2} />
            </label>
          </p>
          <p className={styles.tip}>
            生成的结果的数量。
          </p>
          <p>
            <label >
              <span> Temperature </span>
              <input type="range" min={0} max={2} step={0.05} value={temperature} name="temperature" id="temperature" onChange={(e) => setTemperature(parseFloat(e.target.value))} />
              <span>{temperature}</span>
            </label>
          </p>
          <p>
            <label >
              <span> Top P </span>
              <input type="range" min={0} max={1} step={0.05} name="top_p" id="top_p" onChange={(e) => setTopP(parseFloat(e.target.value))} value={topP} />
              <span>{topP}</span>
            </label>
          </p>
          <p className={styles.tip}>
            使用 Temperature / Top P 参数调整结果的相关性和准确性。当我们需要发散思维、拓宽脑洞时，可适当调低结果的相关性；而当提供的上下文足够多，需要做精确的分析时，则可调高相关性，减少 编造内容的比重。
          </p>
          <p>
            <label >
              <span> Frequency Penalty </span>
              <input min={-2} max={2} defaultValue={0} type="number" name="frequency_penalty" id="frequency_penalty" />
            </label>
          </p>
          <p className={styles.tip}>
            -2.0 到 2.0 之间的数字，用来调整模型对于重复使用相同语句的倾向性。如果数字是正数，它将对新的词汇进行惩罚，模型更倾向于避免重复之前已经生成过的句子，模型会根据文本中已经出现过的词汇频率来减少相同句子的生成概率。如果数字是负数，模型更倾向于生成相同的语句，模型更倾向于重复之前已经生成的句子。因此，这个参数可以帮助模型在生成文本时更好地平衡对于重复和创新的处理。
          </p>
          <p>
            <label >
              <span> Presence Penalty </span>
              <input min={-2} max={2} defaultValue={0} type="number" name="presence_penalty" id="presence_penalty" />
            </label>
          </p>
          <p className={styles.tip}>
            -2.0 到 2.0 之间的数字， 来调整模型对新的词汇或主题的倾向性。如果数字是正数，模型更倾向于谈论已经提到过的词汇或主题。如果数字是负数，则模型更倾向于谈论新的词汇或主题，而不是旧的词汇或主题。
          </p>
        </form>

        <Toaster richColors />
      </main>
    </>
  )
}
